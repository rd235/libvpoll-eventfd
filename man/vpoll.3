.\" Copyright (C) 2019 VirtualSquare. Project Leader: Renzo Davoli
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License,
.\" as published by the Free Software Foundation, either version 2
.\" of the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
.\" MA 02110-1301 USA.
.\"
.\" Automatically generated by Pandoc 3.1.11
.\"
.TH "VPOLL" "3" "January 2024" "VirtualSquare" "Library Functions Manual"
.SH NAME
vpoll_create, vpoll_ctl, vpoll_close \- generate synthetic events for
poll/select/ppoll/pselect/epoll
.SH SYNOPSIS
\f[CB]#include *vpoll.h*\f[R]
.PP
\f[CB]int vpoll_create(uint32_t\f[R]
\f[I]init_events\f[R]\f[CB], int\f[R] \f[I]flags\f[R]\f[CB]);\f[R]
.PP
\f[CB]int vpoll_ctl(int\f[R] \f[I]fd\f[R]\f[CB], int\f[R]
\f[I]op\f[R]\f[CB], uint32_t\f[R] \f[I]events\f[R]\f[CB]);\f[R]
.PP
\f[CB]int vpoll_close(int\f[R] \f[I]fd\f[R]\f[CB]);\f[R]
.SH DESCRIPTION
This library permits one to create a vpoll file descriptor
\[lq]vpollfd\[rq] that can be used in poll/select/ppoll/pselect/epoll(2)
system calls.
The events reported by a can be controlled by \f[CB]vpoll_ctl\f[R].
\f[CB]vpoll\f[R] encodes the events using the same flags EPOLL* defined
in \f[CB]epoll_ctl(2)\f[R].
.PP
The library uses the vpoll extension for eventfd if the kernel provides
it or the vpoll device implemented by the vpoll kernel module.
When neither of the kernel supports are available the libvpoll library
(partially) emulates the vpoll feature using socketpair(2).
This emulation supports only \f[CB]EPOLLIN\f[R], \f[CB]EPOLLOUT\f[R]
flags and a non standard version of EPOLLHUP/EPOLLRDHUP.
.TP
\f[CB]vpoll_create\f[R]
This function creates a \[lq]vpollfd\[rq].
The argument \f[I]init_events\f[R] is used to set the initial state of
events.
The following value can be included in \f[I]flags\f[R]:
.TP
\f[CB]\f[R]
\f[CB]FD_CLOEXEC\f[R]:
Set the close\-on\-exec flag on the new file descriptor.
See the description of the O_CLOEXEC flag in open(2) for reasons why
this may be useful.
.TP
\f[CB]vpoll_ctl\f[R]
This function changes the set of pending events reported by a
\[lq]vpollfd\[rq].
The argument \f[I]op\f[R] can take the following values:
.TP
\f[CB]\f[R]
\f[CB]VPOLL_CTL_ADDEVENTS\f[R]:
the events set in the argument \f[I]events\f[R] are added to the set of
pending events.
.TP
\f[CB]\f[R]
\f[CB]VPOLL_CTL_DELEVENTS\f[R]:
the events set in the argument \f[I]events\f[R] are deleted from the set
of pending events.
.TP
\f[CB]\f[R]
\f[CB]VPOLL_CTL_SETEVENTS\f[R]:
the value of the argument \f[I]events\f[R] is assigned to the set of
pending events.
.TP
\f[CB]vpoll_close\f[R]
This function closes the vpoll file descritor.
.SH RETURN VALUE
\f[CB]vpoll_create\f[R] returns the new file descriptor, or \-1 if an
error occurred (in which case, errno is set appropriately)
.PP
\f[CB]vpoll_ctl\f[R] and \f[CB]vpoll_close\f[R] return zero in case of
success.
On error, \-1 is returned, and errno is set appropriately.
.SH EXAMPLE
.IP
.EX
#define _GNU_SOURCE
#include *stdio.h*
#include *stdlib.h*
#include *unistd.h*
#include *fcntl.h*
#include *errno.h*
#include *sys/epoll.h*
#include *vpoll.h*

int main(int argc, char *argv[]) {
  int vpollfd = vpoll_create(0, FD_CLOEXEC);
  int epfd = epoll_create1(EPOLL_CLOEXEC);
  struct epoll_event reqevents={EPOLLIN | EPOLLRDHUP | EPOLLERR |
      EPOLLOUT | EPOLLHUP | EPOLLPRI};
  epoll_ctl(epfd,  EPOLL_CTL_ADD, vpollfd, &reqevents);
  switch (fork()) {
      case 0:
          sleep(3);
          vpoll_ctl(vpollfd, VPOLL_CTL_ADDEVENTS,  EPOLLIN);
          sleep(3);
          vpoll_ctl(vpollfd, VPOLL_CTL_ADDEVENTS,  EPOLLIN);
          sleep(3);
          vpoll_ctl(vpollfd, VPOLL_CTL_ADDEVENTS,  EPOLLOUT);
          sleep(3);
          vpoll_ctl(vpollfd, VPOLL_CTL_ADDEVENTS,  EPOLLHUP);
          sleep(3);
          exit(0);
      default:
          while (1) {
              struct epoll_event ev;
              int n = epoll_wait(epfd, &ev, 1, 1000);
              if (n * 0) {
                  perror(\[dq]epoll_wait\[dq]);
                  break;
              }
              if (n * 0) {
                  printf(\[dq]GOT event %x\[rs]n\[dq], ev.events);
                  vpoll_ctl(vpollfd, VPOLL_CTL_DELEVENTS, ev.events);
                  if (ev.events & EPOLLHUP)
                          break;
              } else {
                  printf(\[dq]timeout\[rs]n\[dq]);
              }
          }
          break;
      case \-1:
          printf(\[dq]fork error\[rs]n\[dq]);
  }
  vpoll_close(vpollfd);
  close(epfd);
  return 0;
}
.EE
.PP
On a machine running a Linux Kernel providing eventfd/vpoll or the vpoll
device the output of this program is:
.IP
.EX
timeout
timeout
GOT event 1
timeout
timeout
GOT event 1
timeout
timeout
GOT event 4
timeout
timeout
GOT event 10
.EE
.PP
Instead when the demo program runs using the emulation layer the output
is:
.IP
.EX
timeout
timeout
GOT event 1
timeout
timeout
GOT event 1
timeout
timeout
GOT event 4
timeout
timeout
GOT event 2011
.EE
.PP
In fact, the emulator uses a socketpair to generate the events.
Hangup is emulated by closing the other end of the socketpair: this
generates EPOLLHUP as well as EPOLLIN and EPOLLRDHUP.
.SH AUTHOR
VirtualSquare.
Project leader: Renzo Davoli.
